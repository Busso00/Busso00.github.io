<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mandelbrot with WebGPU</title>
  <style>
    body {
      margin: 0;
      display: flex;
    }
    canvas {
      height: 100vh;
      width: 100vh;
    }
    div {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      width: 100vh;
    }
    #zoomIN, #zoomOUT {
      font-size: 5em;
      width: 100px;
      height: 100px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="1000" height="1000"></canvas>
  <div>
    <h1>Explore the Mandelbrot fractal, zoom x2 with "+", zoom x0.5 with "-"</h1>
    <button id="zoomIN">+</button>
    <button id="zoomOUT">-</button>
  </div>

  <script type="module">
    let dim = 4.0;
    let xOffset = 0.0;
    let yOffset = 0.0;

    const canvas = document.getElementById("canvas");
    const zoomInBtn = document.getElementById("zoomIN");
    const zoomOutBtn = document.getElementById("zoomOUT");

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      let deltaY = Math.sign(e.deltaY);
      let deltaX = Math.sign(e.deltaX);
      if (deltaY < 0) yOffset -= 0.02 * dim;
      else if (deltaY > 0) yOffset += 0.02 * dim;
      if (deltaX < 0) xOffset -= 0.02 * dim;
      else if (deltaX > 0) xOffset += 0.02 * dim;
      draw();
    });

    zoomInBtn.onclick = () => {
      dim /= 2;
      draw();
    };
    zoomOutBtn.onclick = () => {
      dim *= 2;
      draw();
    };

    async function initWebGPU() {
      if (!navigator.gpu) {
        alert("WebGPU not supported");
        return;
      }

      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();
      const context = canvas.getContext("webgpu");

      const format = navigator.gpu.getPreferredCanvasFormat();
      context.configure({
        device,
        format,
        alphaMode: "opaque"
      });

      return { device, context, format };
    }

    function createShaderModule(device) {
      return device.createShaderModule({
        code: `
          @group(0) @binding(0) var<uniform> settings: vec4f;
          
          @fragment
          fn main(@builtin(position) coord: vec4f) -> @location(0) vec4f {
            var uv = coord.xy / vec2f(settings.zw);
            var x0 = (uv.x - 0.5) * settings.x + settings.y;
            var y0 = (uv.y - 0.5) * settings.x + settings.y;
            
            var x = 0.0;
            var y = 0.0;
            var i = 0u;
            let maxIter = 256u;
            
            while (x*x + y*y <= 4.0 && i < maxIter) {
              let xtemp = x*x - y*y + x0;
              y = 2.0*x*y + y0;
              x = xtemp;
              i = i + 1u;
            }
            
            if (i == maxIter) {
              return vec4f(1.0, 1.0, 1.0, 1.0);
            }
            let t = f32(i) / f32(maxIter);
            return vec4f(t, 0.5 * t, 1.0 - t, 1.0);
          }

          @vertex
          fn vert(@builtin(vertex_index) idx: u32) -> @builtin(position) vec4f {
            var pos = array<vec2f, 6>(
              vec2f(-1.0, -1.0), vec2f(1.0, -1.0), vec2f(-1.0, 1.0),
              vec2f(-1.0, 1.0), vec2f(1.0, -1.0), vec2f(1.0, 1.0)
            );
            return vec4f(pos[idx], 0.0, 1.0);
          }
        `
      });
    }

    async function draw() {
      const { device, context, format } = await initWebGPU();
      const shaderModule = createShaderModule(device);

      const pipeline = device.createRenderPipeline({
        layout: "auto",
        vertex: {
          module: shaderModule,
          entryPoint: "vert"
        },
        fragment: {
          module: shaderModule,
          entryPoint: "main",
          targets: [{ format }]
        },
        primitive: {
          topology: "triangle-list"
        }
      });

      const uniformBuffer = device.createBuffer({
        size: 4 * 4,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });

      const uniformBindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [
          {
            binding: 0,
            resource: {
              buffer: uniformBuffer
            }
          }
        ]
      });

      const canvasSize = [canvas.width, canvas.height];
      const uniformData = new Float32Array([dim, xOffset, canvasSize[0], canvasSize[1]]);
      device.queue.writeBuffer(uniformBuffer, 0, uniformData);

      const commandEncoder = device.createCommandEncoder();
      const renderPass = commandEncoder.beginRenderPass({
        colorAttachments: [
          {
            view: context.getCurrentTexture().createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 1 },
            loadOp: "clear",
            storeOp: "store"
          }
        ]
      });

      renderPass.setPipeline(pipeline);
      renderPass.setBindGroup(0, uniformBindGroup);
      renderPass.draw(6);
      renderPass.end();

      device.queue.submit([commandEncoder.finish()]);
    }

    draw();
  </script>
</body>
</html>
