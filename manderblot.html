<!DOCTYPE html>
<html>

<head>
    <title>mandelbrot</title>
    <meta charset="UTF-8">
    <meta name="viewport" width="device-width, initial-scale">
    <link rel="icon" type="image/png" href="/favicon/favicon-32x32.png" />

    <style>
        canvas {
            border-radius: 0px;
            height: 100vh;
            width: 100vh;
        }

        body {
            display: flex;
            margin: 0;
        }

        #zoomIN {
            font-size: 5em;
        }

        #zoomOUT {
            font-size: 5em;
        }

        div {
            display: flex;
            flex-direction: column;
            justify-content: center;
            /* vertical */
            align-items: center;
            /* horizontal */
            height: 100vh;
            width: 100vh;
            text-align: center;
        }
    </style>
</head>

<body>

    <div id="target" width="2000" height="2000">
        <canvas id="myCanvas" class="myCanvas" width="1" height="1" color=""></canvas>
    </div>

    <div style="margin:auto;">
        <h1>Explore the manderblot fractal scrolling on it, zoom x2 with "+", zoom x0.5 with "-"</h1>
        <button id="zoomIN" style="width:100px;height:100px;">+</button>
        <button id="zoomOUT" style="width:100px;height:100px;">-</button>
    </div>
    <script src="./lib/gpu-browser.min.js"></script>
    <script type="text/javascript">
        {

            try {
                const HTMLCANVAS = document.getElementById("myCanvas");
                const ctx = HTMLCANVAS.getContext('webgl2', { premultipliedAlpha: false });
                const ZOOMBIN = document.getElementById("zoomIN");
                const ZOOMBOUT = document.getElementById("zoomOUT");
                ctx.canvas.width = window.innerHeight > window.innerWidth ? window.innerWidth : window.innerHeight;
                ctx.canvas.height = ctx.canvas.width;
                const NTH = ctx.canvas.width;


                const gpu = new GPU({
                    HTMLCANVAS,
                    context: ctx
                });

                let dim = 4;
                let xOffset = 0, yOffset = 0;
                let actx = 0;
                let acty = 0;


                HTMLCANVAS.onwheel = (e) => {
                    e.preventDefault();
                    let deltaY = Math.sign(e.deltaY);
                    let deltaX = Math.sign(e.deltaX);
                    if (deltaY < 0)
                        yOffset -= 0.02 * dim;
                    else if (deltaY > 0)
                        yOffset += 0.02 * dim;
                    if (deltaX < 0)
                        xOffset -= 0.02 * dim;
                    else if (deltaX > 0)
                        xOffset += 0.02 * dim;

                    view = new Pixelmap(dim, 2, xOffset, yOffset);

                }

                ZOOMBIN.onclick = function () {

                    view = new Pixelmap(dim /= 2, 2, xOffset, yOffset);

                };
                ZOOMBOUT.onclick = function () {

                    view = new Pixelmap(dim *= 2, 2, xOffset, yOffset);

                };
                HTMLCANVAS.onmousedown = function (evt) {
                    let rect = HTMLCANVAS.getBoundingClientRect();
                    let x = evt.clientX - rect.left;
                    let y = evt.clientY - rect.top;
                    actx = xOffset + (x / ctx.canvas.width) * dim - dim / 2;
                    acty = yOffset + dim / 2 - (y / ctx.canvas.width) * dim;
                    console.log(actx + " " + acty);

                };

                class Pixelmap {
                    constructor(size, n, oX, oY) {
                        this.int = size / ctx.canvas.width;
                        this.canvsize = ctx.canvas.width;
                        console.log(size);
                        let maxiter = 256 / Math.pow(size, 1 / 4) + 1 / Math.pow(size, 1 / 2) + 1 / (256 * size);
                        //let maxiter=128/size;
                        let colormap = gpu.createKernel(function (size, oX, oY, int, maxiter) {
                            let i = this.thread.x;
                            let j = this.thread.y;

                            let n1x = i * int - size + oX;
                            let n1y = size - j * int + oY;
                            let cx = n1x;
                            let cy = n1y;
                            let mij = 0;
                            let temp = n1x;
                            for (; mij < maxiter; mij++) {
                                /*
                                let newmod = Math.pow(Math.sqrt(n1x * n1x + n1y * n1y), n);
                                let newarg = Math.atan(n1y, n1x) * n;
                                n1x = newmod * Math.cos(newarg);
                                n1y = newmod * Math.sin(newarg);
                                */
                                temp = n1x;
                                n1x = n1x * n1x - n1y * n1y;
                                n1y *= 2 * temp;
                                n1x += cx;
                                n1y += cy;
                                if (n1x * n1x + n1y * n1y > 4)
                                    break;
                            }
                            if (mij == maxiter)
                                this.color(255, 255, 255, 1);
                            else if (mij < 96 / 256 * maxiter) {
                                this.color(0, 0, 0, 1);
                            }
                            else if (mij < 128 / 256 * maxiter) {
                                this.color(0, 0, 50, 1);
                            }
                            else if (mij < 160 / 256 * maxiter) {
                                this.color(0, 255, 255, 1);
                            }
                            else if (mij < 192 / 256 * maxiter) {
                                this.color(0, 255, 0, 1);
                            }
                            else if (mij < 224 / 256 * maxiter) {
                                this.color(255, 255, 0, 1);
                            }
                            else {
                                this.color(255, 0, 0, 1);
                            }


                        }).setOutput([NTH, NTH]).setOptimizeFloatMemory(true).setGraphical(true).setLoopMaxIterations(maxiter);
                        colormap(size / 2, oX, oY, this.int, maxiter);

                    }
                }
                let view = new Pixelmap(dim, 2, 0, 0);
                console.log("finish");
            } catch (e) {
                // WebGPU setup
                async function main() {
                    const adapter = await navigator.gpu?.requestAdapter();
                    const device = await adapter?.requestDevice();
                    if (!device) {
                        fail('need a browser that supports WebGPU');
                        return;
                    }

                    // Get a WebGPU context from the canvas and configure it
                    const canvas = document.querySelector('myCanvas');
                    const context = canvas.getContext('webgpu');
                    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
                    context.configure({
                        device,
                        format: presentationFormat,
                    });

                    const module = device.createShaderModule({
                        label: 'our hardcoded rgb triangle shaders',
                        code: `
                    struct OurVertexShaderOutput {
                        @builtin(position) position: vec4f,
                        @location(0) color: vec4f,
                    };

                    @vertex fn vs(
                        @builtin(vertex_index) vertexIndex : u32
                    ) -> OurVertexShaderOutput {
                        let pos = array(
                        vec2f( 0.0,  0.5),  // top center
                        vec2f(-0.5, -0.5),  // bottom left
                        vec2f( 0.5, -0.5)   // bottom right
                        );
                        var color = array<vec4f, 3>(
                        vec4f(1, 0, 0, 1), // red
                        vec4f(0, 1, 0, 1), // green
                        vec4f(0, 0, 1, 1), // blue
                        );

                        var vsOutput: OurVertexShaderOutput;
                        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
                        vsOutput.color = color[vertexIndex];
                        return vsOutput;
                    }

                    @fragment fn fs(fsInput: OurVertexShaderOutput) -> @location(0) vec4f {
                        return fsInput.color;
                    }
                    `,
                    });

                    const pipeline = device.createRenderPipeline({
                        label: 'hardcoded rgb triangle pipeline',
                        layout: 'auto',
                        vertex: {
                            module,
                        },
                        fragment: {
                            module,
                            targets: [{ format: presentationFormat }],
                        },
                    });

                    const renderPassDescriptor = {
                        label: 'our basic canvas renderPass',
                        colorAttachments: [
                            {
                                // view: <- to be filled out when we render
                                clearValue: [0.3, 0.3, 0.3, 1],
                                loadOp: 'clear',
                                storeOp: 'store',
                            },
                        ],
                    };

                    function render() {
                        // Get the current texture from the canvas context and
                        // set it as the texture to render to.
                        renderPassDescriptor.colorAttachments[0].view =
                            context.getCurrentTexture().createView();

                        const encoder = device.createCommandEncoder({
                            label: 'render triangle encoder',
                        });
                        const pass = encoder.beginRenderPass(renderPassDescriptor);
                        pass.setPipeline(pipeline);
                        pass.draw(3);  // call our vertex shader 3 times
                        pass.end();

                        const commandBuffer = encoder.finish();
                        device.queue.submit([commandBuffer]);
                    }

                    const observer = new ResizeObserver(entries => {
                        for (const entry of entries) {
                            const canvas = entry.target;
                            const width = entry.contentBoxSize[0].inlineSize;
                            const height = entry.contentBoxSize[0].blockSize;
                            canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
                            canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
                            // re-render
                            render();
                        }
                    });
                    observer.observe(canvas);
                }

                function fail(msg) {
                    // eslint-disable-next-line no-alert
                    alert(msg);
                }

                main();


            }
        }
    </script>
    </script>
</body>


</html>